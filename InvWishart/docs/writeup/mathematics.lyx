#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection*
The Wishart Distribution
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
.....occurrence, uses..
 relation to Chi2 etc
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
The Bartlett Decomposition
\end_layout

\begin_layout Standard
Under a given variance matrix 
\begin_inset Formula $V$
\end_inset

, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
is this 
\begin_inset Quotes eld
\end_inset

Given a Wishart Matrix W or given A we get a Wishart??
\end_layout

\end_inset

the Bartlett Decomposition
\begin_inset Note Note
status open

\begin_layout Plain Layout
 [cite]
\end_layout

\end_inset

 is the equation.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbf{W} & =\Gamma^{T}A^{T}A\Gamma
\end{align*}

\end_inset

in the context that 
\begin_inset Formula $\Gamma$
\end_inset

 is the upper triangular part of the Cholesky decomposition
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
V= & \Gamma^{T}\Gamma
\end{align*}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
((which is the variance matrix? which is the precision matrix?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and 
\begin_inset Formula $A$
\end_inset

 is a 
\begin_inset Formula $d\times d$
\end_inset

 matrix with entries defined by the 
\series bold
independent 
\series default
random variables
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
TODO: is that+or-1?
\end_layout

\end_inset


\begin_inset Formula 
\begin{align*}
\mathbf{A_{\text{row},\text{column}}}\sim & \begin{cases}
0 & \text{row}>\text{column}\\
\chi_{\text{df}-(\text{row}-1)}^{2} & \text{row}=\text{column}\\
N(0,1) & \text{row}<\text{column}
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
which is upper triangular since everything below the diagonal 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
is 0.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 All this means that 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[cite: Bartlett's Theorem, or whatever]
\end_layout

\end_inset

 
\begin_inset Formula $\mathbf{W}$
\end_inset

 is Wishart-distributed with 
\begin_inset Formula $df$
\end_inset

 
\begin_inset Quotes eld
\end_inset

degrees of freedom
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbf{W} & \sim W(\Gamma^{T}\Gamma,df)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Note that the Bartlett decomposition is also the LU decomposition of 
\begin_inset Formula $\mathbf{W}$
\end_inset

, since the form of the terms in 
\begin_inset Formula $\mathbf{W}=\Gamma^{T}A^{T}A\Gamma$
\end_inset

 is 
\begin_inset Quotes eld
\end_inset

LLUU
\begin_inset Quotes erd
\end_inset

, the product of two lower (or upper) triangular matrices is lower (or upper)
 triangular
\begin_inset Note Note
status open

\begin_layout Plain Layout
 [TODO: proof]
\end_layout

\end_inset

 and the LU decomposition, if it exists, is unique
\begin_inset Note Note
status open

\begin_layout Plain Layout
([todo: proof]) 
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
This theorem has a couple of equivalent forms (Wikipedia 
\begin_inset Note Note
status open

\begin_layout Plain Layout
todo: [CITE]
\end_layout

\end_inset

 for example, defines 
\begin_inset Formula $\mathbf{W}=\Gamma AA^{T}\Gamma^{T}$
\end_inset

, or you could also start from the theorem that 
\begin_inset Formula $A^{T}A\sim W(I,df)$
\end_inset

 and then prove that Wisharts can be scaled: 
\begin_inset Formula $M\sim W(V,df)\wedge(C\text{ is invertible and square})\implies CMC^{T}\sim W(CVC^{T},df)$
\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: proof
\end_layout

\end_inset

).
 We choose this form because the value of 
\begin_inset Formula $chol()$
\end_inset

 in most libraries (certain, in R) is an 
\series bold
upper triangular matrix
\series default
 and following that lead clarifies our derivations and the programs built
 on them.
\end_layout

\begin_layout Subsection*
Generating Wishart Variates
\end_layout

\begin_layout Standard
This decomposition actually gives a useful way to 
\emph on
generate 
\emph default
a desired Wishart distribution: if you want to generate not-quite-covariance
 Wishart matrices and you know (or think you know) 
\begin_inset Formula $V$
\end_inset

 and 
\begin_inset Formula $df$
\end_inset

, you sample 
\begin_inset Formula $A$
\end_inset

 according to the rule above (using 
\begin_inset Formula $df$
\end_inset

), find 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma\leftarrow chol(V)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
, scale 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $U\leftarrow A\Gamma$
\end_inset

, and square that: 
\begin_inset Formula $\mathbf{W}\leftarrow U^{T}U$
\end_inset

.
 The only stochastic part is the generation of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Runtimes
\end_layout

\begin_layout Standard
We traced R's ```rWishart.c``` and worked out that it uses precisely this
 algorithm.
 Translating that R/C/Fortran mixture into pseudocode:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def std_bartlett_factor(d, df): #named std_rWishart_factor in the C
\end_layout

\begin_layout Plain Layout

  A = matrix(d,d)
\end_layout

\begin_layout Plain Layout

  for i in [0 to d-1]:  #note that the matrices are 0-indexed here
\end_layout

\begin_layout Plain Layout

    A[i,i] = sqrt(rchisq(df - i)) #generate X^2_df-(row-1) variates
\end_layout

\begin_layout Plain Layout

    for j in [j+1 to d-1]: #TODO: (d-1 - j+1) = how many elements?
\end_layout

\begin_layout Plain Layout

      A[i,j] = rnorm()            #generate N(0,1) 
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

  return A
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

def rWishart(n, df, V):
\end_layout

\begin_layout Plain Layout

  d = dim(V)[0]
\end_layout

\begin_layout Plain Layout

  assert d == dim(V)[1], "Psi must be square"
\end_layout

\begin_layout Plain Layout

  #Unchecked: Psi must be positive definite
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  gamma = chol(V) #(cache the upper triangular cholesky factor) #lines [...]
\end_layout

\begin_layout Plain Layout

  V = new matrix(d,d,n)
\end_layout

\begin_layout Plain Layout

  for k in [1 to n]:   #(loop to take samples)
\end_layout

\begin_layout Plain Layout

    A = std_bartlett_factor(d, df) #sample A
\end_layout

\begin_layout Plain Layout

    U = A*gamma           #scale the sample
\end_layout

\begin_layout Plain Layout

    V[n] = U'*U           #construct V
\end_layout

\begin_layout Plain Layout

  return V
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
std_Wishart_factor takes 
\begin_inset Formula $O(\frac{d(d+1)}{2})=O(d^{2})$
\end_inset

 time, since it has to operate on half the matrix.
 From Wikipedia 
\begin_inset Note Note
status open

\begin_layout Plain Layout
todo: better cite
\end_layout

\end_inset

 
\begin_inset Formula $chol()$
\end_inset

 takes 
\begin_inset Formula $d^{2}/3$
\end_inset

 time.
 Matrix multiplication, in general, takes 
\begin_inset Formula $O(d^{3})$
\end_inset

 time but the authors of this code use specialized Fortran BLAS routines
 that shorten this slightly to exploit a) the upper triangularness of U
 b) the symmetry of U'U so that the first matrix multiply only takes [...]
 and the secondtakes [...]..
\end_layout

\begin_layout Standard
The routine for a) is called dtrmm.f and the relevant section of its code
 is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

              IF (UPPER) THEN
\end_layout

\begin_layout Plain Layout

                  DO 180 J = N,1,-1
\end_layout

\begin_layout Plain Layout

                      TEMP = ALPHA
\end_layout

\begin_layout Plain Layout

                      IF (NOUNIT) TEMP = TEMP*A(J,J)
\end_layout

\begin_layout Plain Layout

                      DO 150 I = 1,M
\end_layout

\begin_layout Plain Layout

                          B(I,J) = TEMP*B(I,J)
\end_layout

\begin_layout Plain Layout

  150                 CONTINUE
\end_layout

\begin_layout Plain Layout

                      DO 170 K = 1,J - 1
\end_layout

\begin_layout Plain Layout

                          IF (A(K,J).NE.ZERO) THEN
\end_layout

\begin_layout Plain Layout

                              TEMP = ALPHA*A(K,J)
\end_layout

\begin_layout Plain Layout

                              DO 160 I = 1,M
\end_layout

\begin_layout Plain Layout

                                  B(I,J) = B(I,J) + TEMP*B(I,K)
\end_layout

\begin_layout Plain Layout

  160                         CONTINUE
\end_layout

\begin_layout Plain Layout

                          END IF
\end_layout

\begin_layout Plain Layout

  170                 CONTINUE
\end_layout

\begin_layout Plain Layout

  180             CONTINUE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our case, 
\begin_inset Formula $N=M=d$
\end_inset

, so if you squint this says 
\begin_inset Quotes eld
\end_inset

in a d-length loop with itertor j do (a d-length loop and a j*d length loop)
\begin_inset Quotes erd
\end_inset

, which means 
\begin_inset Formula $O(d\cdot(d+\sum_{j=1}^{d}j))=O(d\cdot(d+\frac{d(d+1)}{2}))=O(d^{2}+\frac{d^{3}+d^{2}}{2})=O(\frac{d^{3}+3d^{2}}{2})=O(d^{3})$
\end_inset

 and the structure of dsyrk is almost identical 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: fill in details
\end_layout

\end_inset

 and then there's an extra 
\begin_inset Formula $\frac{d(d+1)}{2}$
\end_inset

 loop in the C code to fill in the symmetric half of the matrix that dsyrk
 doesn't do.
\end_layout

\begin_layout Standard
I won't count the time for memory allocation because that is much more dependent
 how on the 
\begin_inset Formula $malloc$
\end_inset

 in use, how fragmented RAM is, whether a cache is involved, and whether
 
\begin_inset Formula $d^{2}>\text{\ensuremath{malloc} page size}$
\end_inset

.
 Adding this all up, we see that run time of rWishart is 
\begin_inset Formula $O(1)+d^{2}/3+n\cdot(O(\frac{d^{3}+3d^{2}}{2})+O(\frac{d^{3}+3d^{2}}{2}+\frac{d(d+1)}{2}))=O(d^{2}/3+n\cdot(d^{3}+3d^{2}+\frac{d(d+1)}{2}))=O(n\cdot d^{3}+3(n+\frac{1}{3})d^{2}))=O(n\cdot d^{3})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The consequence of this is that is that doubling the number of variates
 
\begin_inset Formula $d$
\end_inset

 in your model will extend your runtime by eight.
 So, a sampler that runs on the order of minutes would run, on double the
 variates, in tens of minutes, and a sampler than runs in tens of minutes
 will take hours.
 Further, techniques like bootstrap sampling generally want 
\begin_inset Formula $n$
\end_inset

>>
\begin_inset Formula $d$
\end_inset

, so in practice runtime is 
\begin_inset Formula $O(d^{4})$
\end_inset

 or higher.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
THIS IS NOT THE CORRECT USE OF O.
 We should use o or 
\backslash
omega or something
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
also 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert Runtime Experiments Here
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
The Inverse Wishart Distribution
\end_layout

\begin_layout Standard
The inverse Wishart distribution shows up when trying.
 It gives 
\emph on
precision matrices
\emph default
 instead of 
\emph on
variance matrices
\emph default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
CITE
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection*
Generating Inverse Wishart Variates
\end_layout

\begin_layout Standard
The naive algorithm for generating inverse wisharts is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def rInvWishart(n, df, P):  #P for "precision"
\end_layout

\begin_layout Plain Layout

  V = invert(P)
\end_layout

\begin_layout Plain Layout

  return [invert(W) for W in rWishart(n, df, V)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With identical runtime to 
\begin_inset Formula $rWishart$
\end_inset

 plus 
\begin_inset Formula $n+1$
\end_inset

 extra inversion operations.
 According to Wikipedia, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations#
Matrix_algebra
\end_layout

\end_inset

 matrix inversion takes between 
\begin_inset Formula $O(d^{2.3})$
\end_inset

 and 
\begin_inset Formula $O(d^{3})$
\end_inset

.
 So the total runtime is in 
\begin_inset Formula $O(n\cdot d^{3})+(n+1)\cdot O(d^{3})=O((2n+1)\cdot d^{3})$
\end_inset

, or roughly twice as slow as 
\begin_inset Formula $rWishart$
\end_inset

.
 This is also dangerous because raw 
\begin_inset Formula $invert()$
\end_inset

 is the most numerically unstable operation around.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Insert Runtime Experiments Here
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
But we can do better (and when we get to the Normal-InverseWishart, the
 same trick we use here will give us extra speedups there).
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Let's take a look at what 
\begin_inset Formula $invert(W)$
\end_inset

 
\series bold
\emph on
is
\series default
\emph default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: state what conditions it takes for inv(W) to exist.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbf{W} & =\Gamma^{T}A^{T}A\Gamma\\
 & =U^{T}U\\
\mathbf{W}^{-1} & =\Gamma^{-1}A^{-1}\left(A^{-1}\right)^{T}\left(\Gamma^{-1}\right)^{T} & \text{invert swaps order, and is swappable with transpose}\\
 & =\Gamma^{-1}A^{-1}\left(\Gamma^{-1}A^{-1}\right)^{T} & \text{transpose swaps order, too}\\
 & =U^{-1}\left(U^{-1}\right)^{T}\\
U^{-1} & =\Gamma^{-1}A^{-1}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Now, recall what 
\begin_inset Formula $\Gamma$
\end_inset

 is: 
\begin_inset Formula $chol(V)=chol(P^{-1})=chol(P)^{-1}$
\end_inset

.
 Here, a lemma 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: prove
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $chol(M^{-1})=chol(M)^{-1}$
\end_inset

, both sides upper triangular.
 So 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
U^{-1} & =\Gamma^{-1}A^{-1}\\
 & =chol(P^{-1})^{-1}A^{-1}\\
 & =\left(chol(P)^{-1}\right)^{-1}A^{-1}\\
 & =chol(P)A^{-1}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $chol(P)$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

 both upper triangular.
\end_layout

\begin_layout Standard
We care about this because it lets us get samples 
\begin_inset Formula $V$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset

:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is there a way to avoid inverting A? Can we ~generate~ A^-1 directly? 
\end_layout

\begin_layout Plain Layout
we know A^TA ~ W(I, df)
\end_layout

\begin_layout Plain Layout
therefore A^-1 A^-1^T ~ W^-1(I^-1, df)
\end_layout

\begin_layout Plain Layout
what is W^-1(I, df)?? is it equidistributed as W(I,df)? -- no, it isn't.
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
no.
 well.
 lets think.
 A[1,1] ~ sqrt(
\backslash
chi^2_df).
 when we invert A, the first element becomes 1/A[1,1].
 so A^-1[1,1] ~ 1/sqrt(
\backslash
chi^2_df).
\end_layout

\begin_layout Plain Layout
the other elements aren't as simple bc they are sums
\end_layout

\begin_layout Plain Layout
we can work it out by the inv(A) = inv(A)*I form + backsolving: column 1
 of inv(A) is inv(A)*[1 0 0 0 ...].
 col 2 is inv(A)*[0 1 0 0 ..] which means
\end_layout

\begin_layout Plain Layout
the last element is 0, the second last is 0, the nthird las ti s 0, .....
 the 2th element has = A[2,1]*S[1] + A[2,2] * S[2] + A[2,3]*S[3] + ...
 = 1.
 and A[2,1] = 0 and S[3] and all higher S are 0 from previousl;y so S[2]
 = 1 / A[2,2].
 And S[1] in col 2 has A[1,1]*S[1] + A[2,1]*S[2] + 0 = 0 => S[1] = -A[2,1]*S[2]/
A[1,1] ~ -N(0,1)/X^2_{6-1} * X^2_{6} -- ..uh.
 a normal times an F (times a scaling factor)??? 
\end_layout

\begin_layout Plain Layout
okay, so this distribution sucks.
\end_layout

\begin_layout Plain Layout
oh wait, no, that's totally fine what I have there: I could, in principle
 (maybe), write.
\end_layout

\begin_layout Plain Layout
except the inverse does NOT have independent columns? experiment
\end_layout

\end_inset

So, for now, it looks like we're stuck inv
\end_layout

\end_body
\end_document
